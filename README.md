# DunzoTask
This is a self-explanatory document that explains/documents on what libraries are used in the project and why they are used even though there are other options available. Libraries that are used in the project are : 

1. Glide for image loading : Glide is hugely popular and apart from that also gives us many features like caching the image for faster retrieval. Another option could have been Picasso which takes up less memory and is CPU-efficient. However, why I chose Glide is because it supports GIF as well as locally stored videos which is not available in Picasso. Thus using Glide helps us give extendability for our app if at a later point of time we decide to include videos/gif.

2. Retrofit for network calls : Volley could have been a better option here, since Volley has caching mechanism and Retrofit doesn't. However using POST requests alongwith Multipart to send files, Retrofit gives us an edge over Volley. Implementing Multipart POST in Retrofit is easier and intuitive than Volley. In Volley we would have to convert the Java classes manually to JSON objects for POST request and some additional code for Multipart requests. In addition to that, Volley supports only 4 network response types versus Retrofit which supports 6-7 response types (mostly the ones we use extensively like String, Object, Boolean, etc,).
Supporting such a wide variety of types especially the multipart post request types, this app can be extended to support image search types as well.

3. Hilt for dependency injection : Dagger 2 is the most widely used dependency injection library compared to Hilt which is very new and has beem released recently. The reason for using Hilt in place of Dagger 2 is because it runs on top of Dagger2 and removed almost all of the boilerplate code that we manually write for all the modules and components classes. Using Hilt not only lets us leverage the power of Dagger2 but also lets us achieve the same functionality with lesser boilerplate code.

4. ObjectBox for storing local data : Here also, we have options like SQLite, Realm and the hugely popular Room database. The reason for choosing ObjectBox here is because for large datasets, Object Box gives better performance for CRUD operations than Room and Realm. Although the one downside is Object Box takes up about 1-2 MB of the apk's size compared to Room which takes up about only 50 KB as it is simply a wrapper over SQLite. However, Object Box not only gives better performance but also supports reactive programming out of the box by supporting reactive streams to listen and update to changes in local data. This helps us making our app reactive without needing to use Rx library(which again takes up a lot of space).

5. RxJava and RxKotlin : Here we could have used coroutines in place of Rx but the reason for using Rx here is for making the network calls reactive. Also, coroutines were created with a single purpose in mind ,i.e., making tasks asynchronous while Rx is a more general tool that gives us a wide variety of options for making our code asynchronous as well as reactive. By having such a wide variety of toold available in our hands, Rx gives us better flexibility as well as extendability also considering the fact that Rx also has a better support for socket programming as compared to coroutines.

The app uses Clean architecture alongwith MVVM design pattern. The reason for choosing MVVM design pattern is because of its support from the Android Jetpack library as well as in helping us painlessly retain data when configuration changes happen. The reason for choosing Clean architecture is because it helps make the app scalable, extendable, testable and easily maintainable. It not only provides good decoupling of the code but also helps us write cleaner code. As a result, our network calls are separated from the views and our business logic is independent of the other outer layers. I have divided the app into packages, namely, the domain, data, di, ui and the utils package. These packages are explained below :
